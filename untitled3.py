# -*- coding: utf-8 -*-
"""Untitled3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1oktx9SGYOSX2Mzz6_bnEn5qELDPd0yzh
"""

!apt-get install -y tesseract-ocr
!pip install pytesseract opencv-python numpy sqlite3
!pip install pymupdf

import cv2
import pytesseract
import sqlite3
import fitz  # PyMuPDF for PDF handling
import hashlib
import numpy as np
import re
from datetime import datetime
from PIL import Image
import sklearn

def create_database():
    conn = sqlite3.connect("bills.db")
    cursor = conn.cursor()
    cursor.execute('''
        CREATE TABLE IF NOT EXISTS bills (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            hash TEXT UNIQUE,
            extracted_text TEXT,
            date TEXT
        )
    ''')
    conn.commit()
    conn.close()

def preprocess_image(image_path):
    image = cv2.imread(image_path)
    gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)
    gray = cv2.GaussianBlur(gray, (5,5), 0)
    _, thresh = cv2.threshold(gray, 150, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
    return thresh

def extract_text(image_path):
    processed_img = preprocess_image(image_path)
    text = pytesseract.image_to_string(processed_img)
    return text.strip()

def generate_hash(text):
    return hashlib.md5(text.encode()).hexdigest()

def extract_date(image_path):
    """Extracts the date from the given bill image using OCR."""
    image = cv2.imread(image_path)
    text = pytesseract.image_to_string(image)

    # Regular expression to match common date formats (DD/MM/YYYY or YYYY-MM-DD)
    date_patterns = [r"\b\d{2}/\d{2}/\d{4}\b", r"\b\d{4}-\d{2}-\d{2}\b"]

    for pattern in date_patterns:
        match = re.search(pattern, text)
        if match:
            return match.group()  # Return the first matched date

    return None

def check_date_mismatch(bill_date, expense_date):
    """Checks if the extracted bill date matches the entered expense date."""
    try:
        bill_date_obj = datetime.strptime(bill_date, "%d/%m/%Y")
        expense_date_obj = datetime.strptime(expense_date, "%d/%m/%Y")

        return bill_date_obj == expense_date_obj  # Returns True if dates match
    except ValueError:
        return False

"""**classify**"""

def classify_bill(text):
    # Keywords indicating business-related expenses
    business_keywords = ['business', 'office', 'work', 'corporate', 'meeting', 'project', 'invoice', 'tax','hostel']

    # Keywords indicating personal-related expenses
    personal_keywords = ['grocery', 'restaurant', 'vacation', 'personal', 'family', 'gift', 'shopping', 'bill']

    # Convert text to lowercase to avoid case-sensitivity issues
    text = text.lower()

    # Check for business-related keywords
    if any(keyword in text for keyword in business_keywords):
        return 'Business'

    # Check for personal-related keywords (if no business keywords were found)
    elif any(keyword in text for keyword in personal_keywords):
        return 'Personal'

    # If no keywords match, default to 'Personal' (or you can change to 'Business')
    else:
        return 'Personal'

def store_bill(image_path, date):
    extracted_text = extract_text(image_path)
    bill_hash = generate_hash(extracted_text)
    bill_date = extract_date(image_path)
    conn = sqlite3.connect("bills.db")
    cursor = conn.cursor()

    # Check if the bill already exists
    class_bill=classify_bill(extracted_text)
    if class_bill=='Business':
        cursor.execute("SELECT * FROM bills WHERE hash=?", (bill_hash,))
        existing_bill = cursor.fetchone()
        if bill_date is None:
            print("⚠️ No valid date found on the bill!")
            return False
        if existing_bill:
            print("⚠ Duplicate bill detected! This bill is already submitted.")
        else:
            if check_date_mismatch(bill_date, date):
                cursor.execute("INSERT INTO bills (hash, extracted_text, date) VALUES (?, ?, ?)", (bill_hash, extracted_text, date))
                conn.commit()
                print("✅ Bill stored successfully!")
            else:
                print("❌ Date mismatch detected! Please check the uploaded bill.")
                return False
    else:
      print("bill uploaded is personal")

    conn.close()

"""pdf bills"""

def extract_text_from_pdf(pdf_path):
    """Extracts text from each page of a multi-page PDF and avoids duplicates."""
    doc = fitz.open(pdf_path)
    bill_images = []
    extracted_texts = set()  # Store text content to check duplicates within the PDF

    for page_num in range(len(doc)):
        pix = doc[page_num].get_pixmap()
        img = Image.frombytes("RGB", [pix.width, pix.height], pix.samples)
        img_path = f"bill_page_{page_num + 1}.jpg"
        img.save(img_path)
        bill_images.append(img_path)

        # Extract text and check for duplicates
        text = pytesseract.image_to_string(img)
        bill_hash = generate_hash(text)

        if bill_hash in extracted_texts:
            print(f"⚠️ Duplicate bill detected in PDF: Page {page_num + 1}, Skipping...")
        else:
            extracted_texts.add(bill_hash)  # Add to in-memory set

    return bill_images, extracted_texts  # Returns images & unique bill hashes from PDF

def store_bill_from_pdf(img_path, extracted_texts):
    """Stores a bill if it is not a duplicate."""
    conn = sqlite3.connect("bills.db")
    cursor = conn.cursor()
    text = pytesseract.image_to_string(Image.open(img_path))
    bill_hash = generate_hash(text)

    # Check if the bill already exists
    cursor.execute("SELECT * FROM bills WHERE hash=?", (bill_hash,))
    existing_bill = cursor.fetchone()
    class_bill=classify_bill(text)
    if class_bill=='Business':
        if bill_hash in extracted_texts:
            print(f"⚠️ Skipping duplicate bill detected: {img_path}")
            return
        if existing_bill:
            print("⚠️ Duplicate bill detected! This bill is already submitted.")
            return
        else:
            cursor.execute("INSERT INTO bills (hash, extracted_text, date) VALUES (?, ?, ?)", (bill_hash, extracted_text, date))
            conn.commit()
            print("✅ Bill stored successfully!")
    else:
        print("bill uploaded is personal")
    conn.close()

def process_multi_bills(pdf_path):
    bill_images, extracted_texts = extract_text_from_pdf(pdf_path)

    for img_path in bill_images:
        store_bill_from_pdf(img_path, extracted_texts)

create_database()

image_path = input("Enter file path") # Change this to your uploaded image path
if image_path.lower().endswith(".pdf"):
    process_multi_bills(image_path)
else:
    date = input("Enter date (DD/MM/YYYY): ")
    store_bill(image_path, date)